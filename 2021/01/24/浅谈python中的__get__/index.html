<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>浅谈python中的__get__ | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. 描述符根据python官方文档的描述，若一个类（或其基类）实现了__get__、__set__、__delete__或__set_name__之一，则该类实例为描述符。  The following methods only apply when an instance of the class containing the method (a so-called descriptor cl">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈python中的__get__">
<meta property="og:url" content="http://example.com/2021/01/24/%E6%B5%85%E8%B0%88python%E4%B8%AD%E7%9A%84__get__/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 描述符根据python官方文档的描述，若一个类（或其基类）实现了__get__、__set__、__delete__或__set_name__之一，则该类实例为描述符。  The following methods only apply when an instance of the class containing the method (a so-called descriptor cl">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-24T11:20:35.098Z">
<meta property="article:modified_time" content="2021-01-24T11:39:13.476Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-浅谈python中的__get__" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/24/%E6%B5%85%E8%B0%88python%E4%B8%AD%E7%9A%84__get__/" class="article-date">
  <time class="dt-published" datetime="2021-01-24T11:20:35.098Z" itemprop="datePublished">2021-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      浅谈python中的__get__
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-描述符"><a href="#1-描述符" class="headerlink" title="1. 描述符"></a>1. 描述符</h2><p>根据<a target="_blank" rel="noopener" href="https://docs.python.org/3.8/reference/datamodel.html">python官方文档</a>的描述，若一个类（或其基类）实现了<code>__get__</code>、<code>__set__</code>、<code>__delete__</code>或<code>__set_name__</code>之一，则该类实例为描述符。</p>
<blockquote>
<p>The following methods only apply when an instance of the class containing the method (a so-called <em>descriptor</em> class) appears in an <em>owner</em> class (the descriptor must be in either the owner’s class dictionary or in the class dictionary for one of its parents). In the examples below, “the attribute” refers to the attribute whose name is the key of the property in the owner class’ <a target="_blank" rel="noopener" href="https://docs.python.org/3.8/library/stdtypes.html#object.__dict__"><code>__dict__</code></a>.</p>
</blockquote>
<p>本文将对<code>__get__</code>协议进行介绍。<br>在下面的例子中，Descriptor实现了<code>__get__</code>协议，因而bar是数据描述符。由于Foo的类属性中，包含了bar这一个实现了<code>__get__</code>的描述符，Foo.bar或foo.bar将导致<code>bar.__get__</code>的调用（如果<code>bar.__dict__</code>中不包含”bar”）。当通过类访问时，instance为None，owner为类；当通过实例访问时，instance为实例本身，而owner为实例类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Descriptor</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&quot;do something&quot;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    bar = Descriptor()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.bar  <span class="comment"># call bar.__get__(None, Foo)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.bar  <span class="comment"># call bar.__get__(foo, Foo)</span></span><br></pre></td></tr></table></figure>
<p><code>__get__</code>协议在python中应用十分广泛，下面将介绍<code>__get__</code>的各种应用。</p>
<h2 id="2-staticmethod"><a href="#2-staticmethod" class="headerlink" title="2. staticmethod"></a>2. staticmethod</h2><p>staticmethod修饰一个函数，将其变为静态方法。静态方法即可以通过类访问，也可以通过类实例访问。<br>staticmethod是通过<code>__get__</code>实现的，通过<code>dir</code>，可以看到staticmethod类是实现了<code>__get__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;__get__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">staticmethod</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>于是，我们可以猜到staticmethod的实现方式。甚至，可以自己实现一个与staticmethod功能一样的staticmethod。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyStaticmethod</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.__func__ = func</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> owner <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        	<span class="keyword">raise</span> TypeError(<span class="string">&#x27;__get__(None, None) is invalid&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.__func__</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">staticmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">&#x27;staticmethod&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    @MyStaticmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">&#x27;MyStaticmethod&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.f()</span><br><span class="line"><span class="built_in">staticmethod</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.f()</span><br><span class="line"><span class="built_in">staticmethod</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.g()</span><br><span class="line">MyStaticmethod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.g()</span><br><span class="line">MyStaticmethod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.f</span><br><span class="line">&lt;function __main__.Foo.f()&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.g</span><br><span class="line">&lt;function __main__.Foo.g()&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-classmethod"><a href="#3-classmethod" class="headerlink" title="3. classmethod"></a>3. classmethod</h2><p>classmethod修饰一个函数，将其变化类方法。类方法可以通过类访问，也能通过实例访问——无论通过哪种方式，都会将类型传递给cls参数。</p>
<p>同样，classmethod也是通过<code>__get__</code>实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;__get__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(<span class="built_in">classmethod</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>__get__</code>自己实现classmethod。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClassmethod</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.__func__ = func</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> owner <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        	<span class="keyword">raise</span> TypeError(<span class="string">&#x27;__get__(None, None) is invalid&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>			<span class="keyword">if</span> owner <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>				owner = <span class="built_in">type</span>(instance)</span><br><span class="line"><span class="meta">... </span>			<span class="comment"># 这里为什么能获得bound method，可以参考本文对象方法部分</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.__func__.__get__(owner)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">&#x27;classmethod&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    @MyClassmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">&#x27;MyClassmethod&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.f()</span><br><span class="line"><span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.f()</span><br><span class="line"><span class="built_in">classmethod</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.g()</span><br><span class="line">MyClassmethod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.g()</span><br><span class="line">MyClassmethod</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.f</span><br><span class="line">&lt;bound method Foo.f of &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Foo</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">foo</span>.<span class="title">g</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">bound</span> <span class="title">method</span> <span class="title">Foo</span>.<span class="title">g</span> <span class="title">of</span> &lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Foo</span>&#x27;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-property"><a href="#4-property" class="headerlink" title="4. property"></a>4. property</h2><p>property实现了<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>，但由于本文的重点是<code>__get__</code>，下面只讨论property和<code>__get__</code>的关系。</p>
<p>property能将一个函数转化为一个属性，实例通过<code>.</code>访问属性，会调用函数。表面上看，函数变成了一个属性。这一点也是通过<code>__get__</code>实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyProperty</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fget</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.fget = fget</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">if</span> owner <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>                <span class="keyword">raise</span> TypeError(<span class="string">&#x27;__get__(None, None) is invalid&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.fget(instance)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    @<span class="built_in">property</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;property f&#x27;</span></span><br><span class="line"><span class="meta">... </span>    @MyProperty</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">g</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">&#x27;MyProperty g&#x27;</span></span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.f</span><br><span class="line"><span class="string">&#x27;property f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.g</span><br><span class="line"><span class="string">&#x27;MyProperty g&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="5-对象方法"><a href="#5-对象方法" class="headerlink" title="5. 对象方法"></a>5. 对象方法</h2><p>众所周知，python是一门面向对象的语言。和C++、Java一样，通过<code>obj.method(...)</code>的语法，一个对象可以调用它的方法。但是，是否有人想过这是如何做到的呢？<code>obj</code>是如何绑定到<code>self</code>参数的呢？</p>
<p>或许有人觉得这种语法是理所当然，但我要说，这不是理所当然的。</p>
<p>在C语言中，不支持这种面向对象的写法；在C++和Java中，调用对象方法时，编译器会将对象的地址或者引用隐含地传递给方法内的this指针或引用。那么，python是如何实现的？我们首先看一个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.bar(foo)</span><br><span class="line">bar</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.bar()</span><br><span class="line">bar</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.bar</span><br><span class="line">&lt;function __main__.Foo.bar(self)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.bar</span><br><span class="line">&lt;bound method Foo.bar of &lt;__main__.Foo <span class="built_in">object</span> at <span class="number">0x000002C896A569D0</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>首先，要注意到虽然可以用<code>foo.bar()</code>调用方法，它以某种方式传递了<code>self</code>参数，但是依然可以通过<code>Foo.bar(foo)</code>的方式显示传递<code>self</code>参数。这说明方法，可以通过类和实例两种方式访问。</p>
<p>进一步，可以发现<code>Foo.bar</code>和<code>foo.bar</code>得到了不同的结果——分别是函数本身和method对象。通过类和实例访问得到不同结果，这一点似曾相识……</p>
<p>通过dir，可以发现函数也实现了<code>__get__</code>协议。python支持方法调用，能够隐含的传递<code>self</code>参数的原因，正是因为<code>__get__</code>。<code>foo.bar</code>的实质是<code>bar.__get__(foo, Foo)</code>，它返回了method对象。method对象可以看做绑定了<code>self</code>参数的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;__get__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(Foo.bar)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;__get__&#x27;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(f)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="6-cached-property"><a href="#6-cached-property" class="headerlink" title="6. cached_property"></a>6. cached_property</h2><p>根据<a target="_blank" rel="noopener" href="https://docs.python.org/3.8/reference/datamodel.html">python官方文档</a>，执行<code>obj.attribute</code>，属性查找顺序如下</p>
<ol>
<li>若type(obj)定义了<code>__getattribute__</code>，则调用<code>type(obj).__getattribute__(obj, &#39;attribute&#39;)</code></li>
<li>若1不满足，但tpye(obj)或其基类包含<code>attribute</code>属性，且attribute同时实现了<code>__get__</code>和<code>__set__</code>，则返回<code>attribute.__get__(obj, type(obj))</code>（假设attribute是指向类属性的引用）</li>
<li>如果1、2不满足，但是<code>obj.__dict__</code>包含了<code>attribute</code>，则直接返回<code>obj.__dict__[&#39;attribute&#39;]</code></li>
<li>若1、2、3不满足，但是tpye(obj)或其基类包含<code>attribute</code>属性<ul>
<li>若类属性<code>attribute</code>实现了<code>__get__</code>，则返回<code>attribute.__get__(obj, type(obj))</code>（假设attribute是指向类属性的引用）</li>
<li>否则，返回类属性<code>type(obj).attribute</code></li>
</ul>
</li>
<li>如果1、2、3、4不满足，但是type(obj)定义了<code>__getattr__</code>方法，则返回<code>type(obj).__getattr__(obj, &#39;attribute&#39;)</code></li>
<li>若以上都不满足，则抛出<code>AttributeError</code>异常</li>
</ol>
<p>从以上规则，可以知道，属性字典<code>obj.__dict__</code>的查找优先于描述符协议<code>__get__</code>（但同时实现了<code>__set__</code>和<code>__get__</code>的数据描述符优先于<code>obj.__dict__</code>）。可以利用这一点实现懒惰加载。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 来自https://github.com/faif/python-patterns</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">lazy_property</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.function = function</span><br><span class="line"><span class="meta">... </span>        functools.update_wrapper(self, function)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, type_</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self</span><br><span class="line"><span class="meta">... </span>        val = self.function(obj)</span><br><span class="line"><span class="meta">... </span>        obj.__dict__[self.function.__name__] = val</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> val</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, occupation</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>        self.occupation = occupation</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>    @lazy_property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">relatives</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment"># Get all relatives, let&#x27;s assume that it costs much time.</span></span><br><span class="line"><span class="meta">... </span>        relatives = <span class="string">&quot;Many relatives.&quot;</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> relatives</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = Person(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.relatives</span><br><span class="line"><span class="string">&#x27;Many relatives.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当person首次访问<code>relatives</code>属性时，由于<code>person.__dict__</code>不包含<code>&#39;relatives&#39;</code>，会导致<code>Person.relatives.__get__(person, Person)</code>的调用。而在<code>__get__</code>调用过程中，<code>val = self.function(obj)</code>、<code>obj.__dict__[self.function.__name__] = val</code>，函数function的返回值被写入<code>person.__dict__</code>（注意，这里用<code>obj.__dict__[self.function.__name__] = val</code>而不是<code>setattr(obj, self.function.__name__, val)</code>是为了绕过<code>__get__</code>的调用）。</p>
<p>当person再次访问<code>relatives</code>属性时，由于<code>person.__dict__</code>已经包含<code>&#39;relatives&#39;</code>，会直接得到<code>person.__dict__[&#39;relatives&#39;]</code>，不会再触发<code>__get__</code>。这实际上实现了懒惰赋值。</p>
<p>实际上，python3.8标注库<code>functools.cached_property</code>实现了类似的功能。cached_property与lazy_property的区别在于</p>
<ul>
<li><p>cached_property使用<code>__set__name__</code>（python3.6新增），获取属性名，而不是<code>func.__name__</code>。当<code>func.__name__</code>以双下划线开头时，有所区别。下面的例子中，<code>__bar.__name__</code>仍为<code>__bar</code>，但通过<code>__bar</code>无法访问属性，但是<code>__set_name__</code>能够获得可以用于访问属性的名字<code>_Foo__bar</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>	<span class="function"><span class="keyword">def</span> <span class="title">__bar</span>(<span class="params">self</span>):</span> ...</span><br><span class="line"><span class="meta">... </span></span><br></pre></td></tr></table></figure></li>
<li><p>cached_property使用锁保证线程安全</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> _thread <span class="keyword">import</span> RLock</span><br><span class="line">_NOT_FOUND = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cached_property</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.attrname = <span class="literal">None</span></span><br><span class="line">        self.__doc__ = func.__doc__</span><br><span class="line">        self.lock = RLock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span>(<span class="params">self, owner, name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.attrname <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.attrname = name</span><br><span class="line">        <span class="keyword">elif</span> name != self.attrname:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">&quot;Cannot assign the same cached_property to two different names &quot;</span></span><br><span class="line">                <span class="string">f&quot;(<span class="subst">&#123;self.attrname!r&#125;</span> and <span class="subst">&#123;name!r&#125;</span>).&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.attrname <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">&quot;Cannot use cached_property instance without calling __set_name__ on it.&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cache = instance.__dict__</span><br><span class="line">        <span class="keyword">except</span> AttributeError:  <span class="comment"># not all objects have __dict__ (e.g. class defines slots)</span></span><br><span class="line">            msg = (</span><br><span class="line">                <span class="string">f&quot;No &#x27;__dict__&#x27; attribute on <span class="subst">&#123;<span class="built_in">type</span>(instance).__name__!r&#125;</span> &quot;</span></span><br><span class="line">                <span class="string">f&quot;instance to cache <span class="subst">&#123;self.attrname!r&#125;</span> property.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">        val = cache.get(self.attrname, _NOT_FOUND)</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> _NOT_FOUND:</span><br><span class="line">            <span class="keyword">with</span> self.lock:</span><br><span class="line">                <span class="comment"># check if another thread filled cache while we awaited lock</span></span><br><span class="line">                val = cache.get(self.attrname, _NOT_FOUND)</span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">is</span> _NOT_FOUND:</span><br><span class="line">                    val = self.func(instance)</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        cache[self.attrname] = val</span><br><span class="line">                    <span class="keyword">except</span> TypeError:</span><br><span class="line">                        msg = (</span><br><span class="line">                            <span class="string">f&quot;The &#x27;__dict__&#x27; attribute on <span class="subst">&#123;<span class="built_in">type</span>(instance).__name__!r&#125;</span> instance &quot;</span></span><br><span class="line">                            <span class="string">f&quot;does not support item assignment for caching <span class="subst">&#123;self.attrname!r&#125;</span> property.&quot;</span></span><br><span class="line">                        )</span><br><span class="line">                        <span class="keyword">raise</span> TypeError(msg) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/24/%E6%B5%85%E8%B0%88python%E4%B8%AD%E7%9A%84__get__/" data-id="ckkb2k8xv0000hkvjd83ndvz0" data-title="浅谈python中的__get__" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/01/19/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/24/%E6%B5%85%E8%B0%88python%E4%B8%AD%E7%9A%84__get__/">浅谈python中的__get__</a>
          </li>
        
          <li>
            <a href="/2021/01/19/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>